<!DOCTYPE html>
<html>
<head>
	<title>Title</title>
	<meta charset="utf-8"><!-- Encoding-->
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<style>

</style>

</head>

<body>

<script>


//1. Insert the keys A, B, C, D, E, F, G, H, I, J, K, L into a binary tree in that order. 

//List the nodes of the tree above in preorder, postorder.



class Node{
    constructor(data){
        this.data = data;
        this.left = null; 
        this.right = null;
    }
}

// Binary Search tree class 
class BinarySearchTree 
{ 
    constructor() 
    { 
        // root of a binary seach tree 
        this.root = null; 
    } 

    // helper method which creates a new node to 
// be inserted and calls insertNode 
insert(data) 
{ 
    // Creating a node and initailising 
    // with data 
    var newNode = new Node(data); 
                    
    // root is null then node will 
    // be added to the tree and made root. 
    if(this.root === null) 
        this.root = newNode; 
    else

        // find the correct position in the 
        // tree and add the node 
        this.insertNode(this.root, newNode); 
} 

// Method to insert a node in a tree 
// it moves over the tree to find the location 
// to insert a node with a given data 
insertNode(node, newNode) 
{ 
    // if the data is less than the node 
    // data move left of the tree 
    if(newNode.data < node.data) 
    { 
        // if left is null insert node here 
        if(node.left === null) 
            node.left = newNode; 
        else

            // if left is not null recurr until 
            // null is found 
            this.insertNode(node.left, newNode); 
    } 

    // if the data is more than the node 
    // data move right of the tree 
    else
    { 
        // if right is null insert node here 
        if(node.right === null) 
            node.right = newNode; 
        else

            // if right is not null recurr until 
            // null is found 
            this.insertNode(node.right,newNode); 
    } 
} 

preorder(node) 
{ 
    if(node !== null) 
    { 
        console.log(node.data); 
        this.preorder(node.left); 
        this.preorder(node.right); 
    } 
} 

// Performs postorder traversal of a tree 
postorder(node) 
{ 
    if(node !== null) //if node is not empty
    { 
        this.postorder(node.left);  //move to left subtree
        this.postorder(node.right); //then right
        console.log(node.data); //then root
    } 
} 
// returns root of the tree 
getRootNode() 
{ 
    return this.root; 
} 


preorder(node) 
{ 
    if(node !== null) 
    { 
        console.log(node.data); 
        this.preorder(node.left); 
        this.preorder(node.right); 
    } 
} 

}  

 


var BST = new BinarySearchTree();


//insert nodes to the BinarySearchTree
BST.insert("A");
BST.insert("B");
BST.insert("C");
BST.insert("D");
BST.insert("E");
BST.insert("F");
BST.insert("G");
BST.insert("H");
BST.insert("I");
BST.insert("J");
BST.insert("K");
BST.insert("L");


var root = BST.getRootNode()
BST.preorder(root);
BST.preorder(root);




//2. In the binary search tree with keys 3, 9, 12, 15, 19, 21, 23 carry out the following operations in sequence: Add 5, add 17, delete 23, delete 9.
/*

// Node class 
class Node 
{ 
    constructor(data) 
    { 
        this.data = data; 
        this.left = null; 
        this.right = null; 
    } 
}

class BinarySearchTree 
{ 
    constructor() 
    { 
        // root of a binary seach tree 
        this.root = null; 
    } 

    // helper method which creates a new node to  
// be inserted and calls insertNode 
insert(data) 
{ 
    // Creating a node and initailising  
    // with data  
    var newNode = new Node(data); 
                      
    // root is null then node will 
    // be added to the tree and made root. 
    if(this.root === null) 
        this.root = newNode; 
    else
  
        // find the correct position in the  
        // tree and add the node 
        this.insertNode(this.root, newNode); 
} 
  
// Method to insert a node in a tree 
// it moves over the tree to find the location 
// to insert a node with a given data  
insertNode(node, newNode) 
{ 
    // if the data is less than the node 
    // data move left of the tree  
    if(newNode.data < node.data) 
    { 
        // if left is null insert node here 
        if(node.left === null) 
            node.left = newNode; 
        else
  
            // if left is not null recurr until  
            // null is found 
            this.insertNode(node.left, newNode);  
    } 
  
    // if the data is more than the node 
    // data move right of the tree  
    else
    { 
        // if right is null insert node here 
        if(node.right === null) 
            node.right = newNode; 
        else
  
            // if right is not null recurr until  
            // null is found 
            this.insertNode(node.right,newNode); 
    } 
}

// helper method that calls the  
// removeNode with a given data 
remove(data) 
{ 
    // root is re-initialized with 
    // root of a modified tree. 
    this.root = this.removeNode(this.root, data); 
} 
  
// Method to remove node with a  
// given data 
// it recurrs over the tree to find the 
// data and removes it 
removeNode(node, key) 
{ 
          
    // if the root is null then tree is  
    // empty 
    if(node === null) 
        return null; 
  
    // if data to be delete is less than  
    // roots data then move to left subtree 
    else if(key < node.data) 
    { 
        node.left = this.removeNode(node.left, key); 
        return node; 
    } 
  
    // if data to be delete is greater than  
    // roots data then move to right subtree 
    else if(key > node.data) 
    { 
        node.right = this.removeNode(node.right, key); 
        return node; 
    } 
  
    // if data is similar to the root's data  
    // then delete this node 
    else
    { 
         // deleting node with no children 
        if(node.left === null && node.right === null) 
        { 
            node = null; 
            return node; 
        } 
  
        // deleting node with one children 
        if(node.left === null) 
        { 
            node = node.right; 
            return node; 
        } 
          
        else if(node.right === null) 
        { 
            node = node.left; 
            return node; 
        } 
  
        // Deleting node with two children 
        // minumum node of the rigt subtree 
        // is stored in aux 
        var aux = this.findMinNode(node.right); 
        node.data = aux.data; 
  
        node.right = this.removeNode(node.right, aux.data); 
        return node; 
    } 
  
}

// Performs inorder traversal of a tree 
inorder(node) //passes node
{ 
    
    if(node !== null)  //checks if node is null
    { 
        this.inorder(node.left); 
        console.log(node.data); 
        this.inorder(node.right); 
    } 
}  
// returns root of the tree 
getRootNode() 
{ 
    return this.root; 
} 


}  


//create an object for the binary tree
var BST = new BinarySearchTree();




//inserting nodes to the BinarySearchTree
BST.insert(3);
BST.insert(9);
BST.insert(12);
BST.insert(15);
BST.insert(19);
BST.insert(21);
BST.insert(23);


//inserting the new nodes
BST.insert(5);
BST.insert(17);

//removing nodes
BST.remove(23);
BST.remove(9);




var root = BST.getRootNode()
BST.inorder(root);

*/


//3.3. T is a binary tree of height 3. What is the largest number of nodes that T can have? What is the smallest number?

//Ans- The height of a binary tree is the largest number of edges in a path from the root node to a leaf node.
//So a tree with height of 3, the number of edges from the root to the leaf is 15 for its largest number and 4 for the smallest number



//4. True or false: In a preorder traversal of a binary search tree, the first item printed out is always the smallest one. If true, explain why; if false, give an example where it is false.

//Ans-
//False. Pre-order traversal starts from the root and moves to the left subtree, then finally the right subtree. The root is not always the smaller number because the values on the left have smaller values than the value at the root of the tree.
//For instance, taking a tree with keys of 10,2,5, 19, 34 -  10 is the root but 2 and 5 are less than 10, but 10 is printed out first because it's the root number, though not the smallest of the numbers. Therefore in pre-order traversal, the first item printed out isn't always the smallest.



//5. Show the result of running the partition subroutine of quicksort on the following array: A=[17, 2, 34, 23, 6, 11, 49, 7, 22, 33]



function quickSort(origArray){ //create a function and pass a parameter called origArray
    if (origArray.length <= 1){ //if the length is less than 1
        return origArray;  // return the array
    }
    else{
        var left = [];
        var right = [];
        var newArray = [];
        var pivot = origArray.pop();
        var length = origArray.length;

        for (var i = 0; i < length; i++){
            if(origArray[i] <= pivot){
                left.push(origArray[i]);
            }
            else{
                right.push(origArray[i]);
            }
        }

        return newArray.concat(quickSort(left),pivot, quickSort(right));

    }
}

var Array = [17, 2, 34, 23, 6, 11, 49, 7, 22, 33];

console.log("Original array: " + Array);
var sortedArray = quickSort(Array);
console.log("Sorted array: " + sortedArray);





</script>


</body>
</html>
